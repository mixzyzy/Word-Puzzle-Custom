<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Search Game (with Timers)</title>
  <style>
    body{font-family:Arial,sans-serif;background:#f9f9f9;margin:0}

    /* remove top title – save space */
    #main-container{
      display:flex;
      justify-content:center;
      align-items:flex-start;
      gap:40px;
      padding-top:20px; /* small breathing room */
    }

    /* side panels (timer / button / score) */
    #controls{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
    }
    .team-button{
      padding:15px 25px;
      font-size:18px;
      cursor:pointer;
      border:1px solid #aaa;
      border-radius:5px;
      width:120px;
      color:#fff;
    }
    .team-button.team-a{background:red}
    .team-button.team-b{background:blue}
    .score{font-size:20px;color:#333}
    .timer{font-size:24px;font-weight:bold;color:#222}

    /* grid */
    #grid{
      display:grid;
      grid-template-columns:repeat(10,40px);
      gap:2px;
      justify-content:center;
    }
    .cell{
      width:40px;height:40px;
      display:flex;align-items:center;justify-content:center;
      background:#fff;border:1px solid #ccc;
      cursor:pointer;user-select:none;font-size:18px;
    }
    .found{background:rgba(135,206,235,.6)}
    .hint{background:rgba(255,255,0,.4)}
    .team-a{background:rgba(255,0,0,.3)!important}
    .team-b{background:rgba(0,0,255,.3)!important}

    /* word list */
    #wordBox{
      display:flex;justify-content:center;gap:20px;margin-top:20px;
      align-items:flex-start;
    }
    #wordList{max-width:320px;text-align:left}
    #wordList h3{margin:0 0 6px 0;font-size:22px}
    #wordList ol{
      column-count:3;          /* 3 columns */
      column-gap:16px;
      margin:0;padding-left:20px;
    }
    #wordList li{font-size:18px;line-height:1.4}

    /* other buttons */
    #hintButton{
      align-self:flex-start;
      padding:10px 20px;font-size:16px;
      cursor:pointer;background:#eee;border:1px solid #aaa;border-radius:5px;
      height:fit-content;
    }
    #pagination{margin:30px auto;text-align:center}
    #pagination button{padding:8px 15px;margin:0 10px;font-size:14px}
    #reloadButton{
      margin-top:15px;padding:10px 20px;font-size:16px;
      cursor:pointer;display:none;
    }
  </style>
</head>
<body>
<!-- (title removed) -->
<div id="main-container">
  <div id="controls">
    <div class="timer" id="timerA">Time: 60</div>
    <button class="team-button team-a" onclick="selectTeam('A')">Team A</button>
    <div class="score">Score: <span id="scoreA">0</span></div>
  </div>

  <div>
    <div id="grid"></div>

    <div id="wordBox">
      <div id="wordList"></div>
      <button id="hintButton">Hint</button>
    </div>

    <div id="pagination">
      <button onclick="prevPage()">Previous</button>
      <span id="pageLabel">Page 1</span>
      <button onclick="nextPage()">Next</button>
      <br>
      <button id="reloadButton" onclick="reloadGame()">Reload Game</button>
    </div>
  </div>

  <div id="controls">
    <div class="timer" id="timerB">Time: 60</div>
    <button class="team-button team-b" onclick="selectTeam('B')">Team B</button>
    <div class="score">Score: <span id="scoreB">0</span></div>
  </div>
</div>

<script>
/* ───────────── TIMER LOGIC ───────────── */
const timers   = {A:60, B:60};
const intervals= {A:null, B:null};

function updateTimerDisplay(team){
  document.getElementById(`timer${team}`)
          .textContent = `Time: ${String(timers[team]).padStart(2,'0')}`;
}

function resetTimer(team){
  clearInterval(intervals[team]);
  timers[team] = 60;
  updateTimerDisplay(team);
}

function startTimer(team){
  resetTimer(team);                      // always start from 60
  intervals[team] = setInterval(()=>{
    timers[team]--;
    updateTimerDisplay(team);
    if (timers[team] <= 0){
      clearInterval(intervals[team]);
      flashColor('#ffdddd');
      penalize();
      resetSelection();
      const expired=currentTeam;
      currentTeam=null;
      resetTimer(expired);
    }
  },1000);
}
/* ─────────── END TIMER LOGIC ─────────── */

const gridSize=10;
let currentTeam=null, scoreA=0, scoreB=0, page=0;
let currentSelection=[], currentWord='', lastIndex=-1, direction=null;
let foundWords=new Set(), tempGrid;

const NO_MASK=['camel','rhino','chair','fries'];    // words that never mask
const OPTIONAL_MISSING=[...NO_MASK];                // used later

const directions=[                                  // 4 common directions
  {dx:1, dy:0, delta:1},                 // →
  {dx:0, dy:1, delta:gridSize},          // ↓
  {dx:1, dy:1, delta:gridSize+1},        // ↘
  {dx:1, dy:-1,delta:-gridSize+1}        // ↗
];
const allowed=directions.map(d=>d.delta);

const gridDiv=document.getElementById('grid'),
      wordListDiv=document.getElementById('wordList');

/* 6 pages of data (first page has pre-baked grid, others auto-generate) */
const pageData=[
  {grid:[
    'K','B','F','J','D','M','R','I','C','E','D','O','G','Z','C','I','I','U','T','Q',
    'C','W','Y','F','A','L','C','C','L','I','A','X','K','A','T','K','E','S','Q','A',
    'K','A','N','F','Z','T','J','O','T','P','E','L','J','H','X','K','B','K','P','P',
    'V','F','S','X','N','H','C','V','D','L','Z','I','I','T','D','L','M','P','U','E',
    'F','B','A','N','A','N','A','F','C','X','P','I','G','X','Q','B','U','Y','K','Y'
  ],
   words:['cat','dog','fish','apple','banana','rice','milk','pig','cake','duck']},

  {words:['tiger','zebra','panda','monkey','lion','bear','wolf',
          'horse','camel','rhino']},

  {words:['pizza','burger','sushi','pasta','noodle',
          'steak','fries','salad','bread','cheese']},

  {words:['red','blue','green','yellow','purple',
          'orange','white','black','pink','brown']},

  {words:['grape','pen','cloud','car','juice',
          'dog','chair','bag','milk','cat']},

  {words:['apple','sun','ball','book','rice',
          'bird','ice','fan','egg','toy']}
];

/* ──────────── helper utilities ──────────── */
function updateScores(){
  document.getElementById('scoreA').textContent = scoreA.toFixed(1);
  document.getElementById('scoreB').textContent = scoreB.toFixed(1);
}
function randomLetter(){ return String.fromCharCode(65+Math.floor(Math.random()*26)); }

function canPlace(word,r,c,dir){
  const len=word.length,
        endR=r+dir.dy*(len-1),
        endC=c+dir.dx*(len-1);
  if(endR<0||endR>=gridSize||endC<0||endC>=gridSize) return false;
  for(let i=0;i<len;i++){
    const rr=r+dir.dy*i, cc=c+dir.dx*i, idx=rr*gridSize+cc;
    if(tempGrid[idx] && tempGrid[idx]!==word[i]) return false;
  }
  return true;
}
function placeWord(word){
  for(let t=0;t<200;t++){
    const dir=directions[Math.floor(Math.random()*directions.length)],
          r=Math.floor(Math.random()*gridSize),
          c=Math.floor(Math.random()*gridSize);
    if(!canPlace(word,r,c,dir)) continue;
    for(let i=0;i<word.length;i++){
      const rr=r+dir.dy*i, cc=c+dir.dx*i;
      tempGrid[rr*gridSize+cc] = word[i];
    }
    return true;
  }
  return false;
}
function generateGrid(words){
  tempGrid = new Array(gridSize*gridSize).fill(null);
  words.forEach(w=>placeWord(w.toUpperCase()));
  return tempGrid.map(ch=>ch || randomLetter());
}
function maskedDisplay(w){
  if(NO_MASK.includes(w) || w.length<2) return w;
  const pos = Math.floor(Math.random()*w.length);
  return w.slice(0,pos) + '_' + w.slice(pos+1);
}
/* ─────────── selection & teams ─────────── */
function selectTeam(t){
  currentTeam = t;
  resetSelection();
  startTimer(t);
}
function flashColor(col){
  const o=document.body.style.backgroundColor;
  document.body.style.backgroundColor=col;
  setTimeout(()=>document.body.style.backgroundColor=o,300);
}
function resetSelection(){
  currentSelection.forEach(c=>c.classList.remove('team-a','team-b'));
  currentSelection=[];
  currentWord='';
  lastIndex=-1;
  direction=null;
}
function penalize(){
  if(currentTeam==='A'){ scoreA-=0.5; resetTimer('A'); }
  else if(currentTeam==='B'){ scoreB-=0.5; resetTimer('B'); }
  updateScores();
}

/* ─────────── word-search helpers ─────────── */
function wordExists(word,arr){
  const target=word.toUpperCase();
  for(let i=0;i<arr.length;i++){
    for(const d of allowed){
      let ok=true;
      for(let j=0;j<target.length;j++){
        const idx=i+j*d;
        if(idx<0||idx>=arr.length){ ok=false; break; }
        if(d===1 && Math.floor(idx/gridSize)!==Math.floor(i/gridSize)){ ok=false; break; }
        const ch=arr[idx].textContent ? arr[idx].textContent : arr[idx];
        if(ch!==target[j]){ ok=false; break; }
      }
      if(ok) return true;
    }
  }
  return false;
}
function highlightWord(word,grid){
  const target=word.toUpperCase();
  for(let i=0;i<grid.length;i++){
    for(const d of allowed){
      const pos=[]; let built='';
      for(let j=0;j<target.length;j++){
        const idx=i+j*d;
        if(idx<0||idx>=grid.length) break;
        if(d===1 && Math.floor(idx/gridSize)!==Math.floor(i/gridSize)) break;
        const cell=grid[idx];
        built+=cell.textContent;
        pos.push(cell);
      }
      if(built===target){
        pos.forEach(c=>c.classList.add('found'));
        return;
      }
    }
  }
}
function showHint(){
  const data=pageData[page],
        cells=[...gridDiv.children];
  const candidates=data.words.filter(w=>!foundWords.has(w) && wordExists(w,cells));
  if(!candidates.length) return alert('No more hints');
  const word=candidates[Math.floor(Math.random()*candidates.length)].toUpperCase();

  for(let i=0;i<cells.length;i++){
    for(const d of allowed){
      const pos=[]; let built='';
      for(let j=0;j<word.length;j++){
        const idx=i+j*d;
        if(idx<0||idx>=cells.length) break;
        if(d===1 && Math.floor(idx/gridSize)!==Math.floor(i/gridSize)) break;
        const cell=cells[idx];
        built+=cell.textContent;
        pos.push(cell);
      }
      if(built===word){
        pos.forEach(c=>c.classList.add('hint'));
        setTimeout(()=>pos.forEach(c=>c.classList.remove('hint')),1000);
        return;
      }
    }
  }
}

/* ─────────────── page handling ─────────────── */
function loadPage(){
  const data=pageData[page];

  /* make grid first time */
  if(!data.grid) data.grid = generateGrid(data.words);
  if(!data.foundWords) data.foundWords = new Set();
  foundWords = data.foundWords;

  /* fallback: mark words that accidentally aren’t in grid */
  OPTIONAL_MISSING.forEach(w=>{
    if(data.words.includes(w) && !wordExists(w,data.grid) && !foundWords.has(w))
      foundWords.add(w);
  });

  /* draw grid */
  gridDiv.innerHTML='';
  data.grid.forEach(l=>{
    const cell=document.createElement('div');
    cell.className='cell';
    cell.textContent=l;
    gridDiv.appendChild(cell);
  });

  /* draw word list */
  document.getElementById('pageLabel').textContent = `Page ${page+1}`;
  wordListDiv.innerHTML =
    '<h3>Find These Words:</h3><ol>' +
    data.words.map(w=>
      foundWords.has(w)
        ? `<li data-word="${w}"><del>${maskedDisplay(w)}</del></li>`
        : `<li data-word="${w}">${maskedDisplay(w)}</li>`
    ).join('') +
    '</ol>';

  /* hook cell clicks */
  const cells=[...gridDiv.children];
  cells.forEach(c=>c.addEventListener('click',e=>handleClick(e,cells,data.words)));

  /* visually re-highlight words already found */
  foundWords.forEach(w=>highlightWord(w,cells));

  updateScores();
  document.getElementById('reloadButton').style.display =
     page===pageData.length-1 ? 'inline-block' : 'none';

  resetSelection();
  currentTeam=null;         /* new page => no active team */
  resetTimer('A'); resetTimer('B');
}

/* ───────────── click handling ───────────── */
function handleClick(e,cells,words){
  if(!currentTeam) return alert('Select Team first');

  const cell=e.target,
        idx = cells.indexOf(cell);

  if(!cell.textContent.match(/[A-Z]/)) return;

  /* first letter of a path */
  if(lastIndex===-1){
    currentSelection.push(cell);
    currentWord += cell.textContent.toLowerCase();
    cell.classList.add(currentTeam==='A'?'team-a':'team-b');
    lastIndex=idx;
    return;
  }

  /* step must follow same direction */
  const diff = idx - lastIndex;
  if(direction===null && allowed.includes(diff)) direction = diff;
  if(idx !== lastIndex + direction){
    flashColor('#ffdddd');
    penalize();
    resetSelection();
    currentTeam=null;
    return;
  }

  currentSelection.push(cell);
  currentWord += cell.textContent.toLowerCase();
  cell.classList.add(currentTeam==='A'?'team-a':'team-b');
  lastIndex = idx;

  /* shortcut: if no word starts with built string, early fail */
  if(!words.some(w=>w.startsWith(currentWord))){
    flashColor('#ffdddd');
    penalize();
    resetSelection();
    currentTeam=null;
    return;
  }

  /* full word found */
  if(words.includes(currentWord) && !foundWords.has(currentWord)){
    flashColor('#ddffdd');
    currentSelection.forEach(c=>c.classList.remove('team-a','team-b'));
    currentSelection.forEach(c=>c.classList.add('found'));
    foundWords.add(currentWord);

    /* strike-through in list */
    [...wordListDiv.querySelectorAll('li')].forEach(li=>{
      if(li.dataset.word===currentWord)
        li.innerHTML = `<del>${li.textContent}</del>`;
    });

    if(currentTeam==='A'){ scoreA+=1; resetTimer('A'); }
    else                  { scoreB+=1; resetTimer('B'); }
    updateScores();

    resetSelection();
    currentTeam=null;
  }
}

/* ─────────── navigation / reset ─────────── */
function nextPage(){ page=(page+1)%pageData.length; loadPage(); }
function prevPage(){ page=(page-1+pageData.length)%pageData.length; loadPage(); }
function reloadGame(){
  scoreA=0; scoreB=0;
  pageData.forEach(p=>p.foundWords=new Set());
  page=0;
  loadPage();
}

/* hooks */
document.getElementById('hintButton').addEventListener('click',showHint);
loadPage();   // initial render
</script>
</body>
</html>
